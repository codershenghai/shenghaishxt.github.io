<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[调整主页的宽度]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%B0%83%E6%95%B4%E6%96%87%E7%AB%A0%E7%9A%84%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[博客在浏览器上的留白太多，因此想增加文章的宽度。对于Pisces Scheme，修改页面宽度的方式与其他三个主题不太一样，因此列出Pisces Scheme的修改方式。 打开/Hexo/themes/hexo-theme-next/source//css/_variables/custom.styl 添加两行代码即可： 12$main-desktop = 1200px $content-desktop = 900px]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用DNSPOD进行域名解析]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BD%BF%E7%94%A8DNSPOD%E8%BF%9B%E8%A1%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前的域名解析有两种方法，一种是直接利用域名注册商的解析，另一种就是更换DNS用第三方的解析。为了便于管理，也为了更好的速度，将域名的解析方式由namesilo默认的解析方式改为使用国内的DNSPOD进行解析。 首先在namesilo上更换域名DNS（即Change Name Servers），将原来默认的Name Servers改为 12f1g1ns1.dnspod.netf1g1ns1.dnspod.net 删除默认的A记录和CNAME记录，等待DNSPOD的免费DNS更新完毕后就可以放心地关闭namesilo了。 然后打开DNSPOD控制台，添加域名即可。由于本博客是用Github托管的，因此这里记录了连接到Github博客的设置，也可以连接到自己的VPS，IP改为自己的VPS地址即可。 123@ A 192.30.252.153@ A 192.30.252.154www CNAME shenghaishxt.github.io A： 用来指定域名为 IPv4 的地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加 A 记录。CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录。 最后在本地的/Hexo/source文件夹下新建CNAME文件，注意不要带任何后缀，如果想要自己的网站是带有www的二级域名，那么就输入带有www的域名，否则的话直接添加自己购买的域名就好。我这里添加的是带有www的二级域名。 1www.zhangshenghai.com 接下来就等待DNS的解析啦，不知道为什么我的解析好像挺慢的。十几分钟后zhangshenghai.com这个域名是可以ping通，但加了www的域名就总是ping不通。貌似是过了一个晚上，我第二天打开才可以登陆上。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER10 线性规划在近似算法中的应用]]></title>
    <url>%2F2018%2F12%2F12%2FCHAPTER10%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%9C%A8%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用线性规划来近似顶点覆盖问题ILP（整数线性规划）对于每一个顶点$v\in V$，有$x(v) \in {0, 1}$，$x(v)=1$意为v在顶点覆盖中，$x(v)=0$意为v不再顶点覆盖中。那么，对于顶点覆盖问题的任意边$(u, v)$，u和v至少有一个必须在顶点覆盖中，即$x(u)+x(v)\geq1$。这样就引出了以下用于寻找最小顶点覆盖的0-1整数规划 。$$min \sum_{v\in V} x(v)\s.t.\qquad x(u)+x(v) \geq 1 \quad \forall (u,v)\in E \ \quad x(v)\in {0, 1} \quad \forall v \in V$$ relax to LP（线性规划松弛）假设去掉了$x(v) \in {0, 1}​$这一限制，并代之以$0\leq x(v) \leq 1​$，就可以得到以下的线性规划，称为线性规划松弛。$$min \sum_{v\in V} x(v)\s.t.\qquad x(u)+x(v) \geq 1 \quad \forall (u,v)\in E \ \quad 0\leq x(v) \leq 1 \quad \forall v \in V$$ Rounding（使用Rounding的方法来构造近似算法）对于每一个顶点v，都会求得一个$x(v)$的值$x^*(v)$，对$x(v)$做以下的rounding： 若$x^*(v)\geq 1/2$，则将该顶点加入到点覆盖集合中（$x(v)= 1$），否则舍去顶点v（$x(v) = 0​$），直至图中的所有顶点处理完毕。 由以上算法可看出： 故此算法是一个近似度为2的近似算法。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER9 线性规划]]></title>
    <url>%2F2018%2F12%2F11%2FCHAPTER9%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[线性规划概述在给定有限的资源和竞争约束情况下，很多问题都可以表达为最大化或最小化某个目标。如果可以把目标指定为某些变量的一个线性函数，而且如果可以将资源的约束指定为这些变量的等式或不等式，则得到一个线性规划问题（Linear-Programming Problem）。 在求解线性规划时又两种有用的格式：标准型和松弛型。在标准型中所有的约束都是不等式，而在松弛型中所有的约束都是等式。 下面给出一个将实际问题转换为线性规划形式的例子。 有m种不同的食物$F_1, …, F_m$，这些食物能够提供n种营养$N_1, …, N_n$，营养$N_j$每天的最低需求量是$c_j$，$b_i$是$F_i$的单位价格。$a_{ij}$代表食物$F_i$单位体积所含的营养$N_j$。问题是求在满足营养需求下的最小花费。 假设每种食物的数量为$x_i$，则使用线性规划的形式可表示为：$$min \sum_i b_i x_i \s.t. \sum_i a_{ij}x_i \geq c_j$$这个问题的目标是求满足营养需求的条件下最小化价格，接下来我们会看到，其实它的对偶问题就是最大化营养的需求量。 单纯形算法解决线性规划问题主要用三种算法： 单纯形算法：指数时间的复杂度，但是在实际中应用广泛，当它被精心实现时，通常能够快速地解决一般的线性规划问题。 椭圆算法：第一个指数时间算法，但是在实际中运行缓慢。 内点法：在理论和实际中都能比较有效率地解决线性规划问题。 本章我们主要讨论在实际问题中应用广泛的单纯形算法。 首先从一个例子开始，考虑下列松弛型的线性规划并将等式重写后可得到一个tableau： 现在，$x_3, x_4, x_5$是基本解，令$x_1=x_2=0$，可得$x_3=1, x_4=3, x_5=2$，且$z=0$。 我们当然希望改善$z$的值，很明显需要增加$x_1$或者$x_2$。令$x_1=0$，由于$x_1, …, x_5 \geq 0$，$x_2$最大可取至1，此时$x_3=0$。现在基本解变为$x_2, x_4, x_5$，重写tableau： 重复上面的过程，为了增加$z$的值，我们可以增加$x_1$（由于$x_3$的系数是负数，因此增加$x_3$是无效的）。令$x_3=0$，$x_1$最大可取至1，此时$x_5=0$。这时基本解变为$x_1, x_2, x_4$，重写tableau： 重复上面的过程，为了增加$z$的值，我们可以增加$x_3$（由于$x_5$的系数是负数，因此增加$x_5$是无效的）。令$x_5=0$，$x_3$最大可取至2，此时$x_4$变为0。这时基本解变为$x_1, x_2, x_3$，重写tableau： 此时可看出$z$的取值已达最优，因此解是$x_1=3, x_2=2, x_3=2, x_4=0, x_5=0$，目标值$z=5$。 对偶性对偶性是个非常重要的性质。在一个最优化问题中，一个对偶问题的识别几乎总是伴随着一个多项式时间算法的发现。 在线性规划的形式下，对偶问题可互相转化，具体如下图所示： 下面给出一个实际例子，照着原问题的线性规划形式，我们即可写出对偶问题的线性规划形式。 原问题有多少个未知数，对偶问题就有多少个式子；原问题有多少个式子，对偶问题就有多少个未知数。 如下图所示，原问题给出了对偶问题的可行解的下界，对偶问题给出了原问题的可行解的上界。 总结几个经典的对偶问题： 最大流的对偶问题是最小割 最大匹配的对偶问题是最小顶点覆盖 最优匹配的对偶问题是最小定标和 最大流与最小割的线性规划表示最大流满足两个性质：反对称性、容量限制。最大流是满足这两个约束和最大化流量值的流，其中流量值是从源流出的总流量。因此，流满足线性约束，且流的值是一个线性函数。可以将最大流问题表示为线性规划并作如下的转换： 其对偶问题的实际意义是最小割：]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER8 近似算法]]></title>
    <url>%2F2018%2F12%2F10%2FCHAPTER8%20%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目前，所有的NP完全问题都没有能够在多项式时间内求解的算法，我们通常可以采用以下几种解题策略： 只对问题的特殊实例求解 用动态规划法或分支限界法求解 用概率算法求解 只求近似解 用启发式方法求解 本节主要讨论的是解NP完全问题的近似算法。 近似算法的性能若一个最优化问题的最优值为$C^{OPT}$，求解该问题的一个近似算法的一个近似最优解相应的目标函数值为$C$，则将近似算法的性能比定义为：$$\eta = max({\frac{C}{C^{OPT}}, \frac{C^{OPT}}{C}})$$通常情况下，该性能比是问题输入规模$n$的一个函数$\rho(n)$，即$$max({\frac{C}{C^{OPT}}, \frac{C^{OPT}}{C}}) \leq \rho(n)$$ 顶点覆盖问题的近似算法问题描述无向图$G=(V,E)$的顶点覆盖是它的顶点集$V$的一个子集$V’⊆V$，使得若$(u,v)$是$G$的一条边，则$v∈V’$或$u∈V’$。顶点覆盖V’的大小是它所包含的顶点个数$|V’|$。 下面给出一个近似比为2的算法的伪代码： 123456789101112VertexSet approxVextexCover(Graph g)&#123; cset = NULL; e = g.e; while (e != NULL) &#123; 从e中任取一条边(u, v); 将顶点u,v加入cset; 从e中删去与u和v相关联的边; &#125; return cset;&#125; 算法运行过程下图是《算法导论》中顶点覆盖问题近似算法的图例，说明了算法的运行过程和结果。 图(e)表示近似算法产生的近似最优顶点覆盖cset，它由顶点b,c,d,e,f,g所组成。图(f)是图G的一个最小顶点覆盖，它只含有3个顶点：b,d和e。 性能分析假定算法选取的边集为A，则返回的顶点个数为2A。即$|C| = 2|A|$。图G的任一顶点覆盖都至少包含A中各条边中的一个顶点，即$|C^{OPT}| \geq |A|$。 则$$\rho = \frac{|C|}{|C^{OPT}|} \leq 2$$ 旅行商问题的近似算法问题描述给定一个完全无向图$G=(V,E)$，其每一边$(u,v)∈E$有一非负整数费用$c(u,v)$。要找出$G$的最小费用哈密顿回路。 费用函数c往往具有三角不等式性质，即对任意的3个顶点$u,v,w∈V$，有：$c(u,w)≤c(u,v)+c(v,w)$。 在费用函数不一定满足三角不等式的一般情况下，不存在具有常数性能比的解TSP问题的多项式时间近似算法，除非$P=NP$。换句话说，若$P≠NP$，则对任意常数$ρ&gt;1$，不存在性能比为ρ的解决旅行售货员问题的多项式时间近似算法。 下面给出一个解决满足三角不等式的旅行商问题的近似算法伪代码： 123456APPROX-TSP-TOUR(G, c) 任意选择V中的一个顶点r，作为树根节点 调用Prim算法得到图G的最小生成树T 先序遍历T，得到顶点序列L 删除L中的重复顶点形成哈密顿环C 输出C 算法运行过程下图是APPROX-TSP-TOUR的操作过程，(a)示出了给定点的集合，(b)示出了一个最小生成树T，它是由MST-PRIM计算出来的，根为a节点，(c)是对T进行先序遍历时的顶点序列，(d)是近似算法得到的路线。 性能分析假设$H ^ {opt}​$是一个最优游程，如图e所示。由于我们通过删除一个游程路线中的任一边而得到一棵生成树，故最小生成树$T​$的权值是最优游程代价的一个下界，即$c(T) \leq c(H^{opt})​$。 假设图c中的遍历的代价为$c(W)$，该遍历经过了$T$的每条边两次，则有$c(W) = 2c(T)$，两式联立有$c(W) \leq 2c(H^{opt})$。由于$H$是从完全遍历$W$中删除了某些顶点得到的，故有$c(H) \leq c(W)$，则$c(H) \leq2c(H^{opt})$。 则$$\frac{C(H)}{C({H^{opt}})} \leq 2$$]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER7 NP完全性]]></title>
    <url>%2F2018%2F12%2F09%2FCHAPTER7%20NP%E5%AE%8C%E5%85%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[P问题、NP问题、NPC问题的概念老师上课时强调过本章对于概念要特别清楚，因此首先给出这三个问题的概念： P问题：能够在多项式时间内解决的问题。 NP问题：能够在多项式时间内验证一个解的正确性的问题。 NPC问题：当一个问题满足下面两个条件的时候，那么这个问题是NPC问题。 首先，它是NP问题。 其次，所有其他的NP问题都能够在多项式时间内归约到此问题上（NP-hard）。 NPC问题是NP问题的子集。 NP-hard问题：问题A不一定是一个NP问题，但是所有的NPC问题都可以在多项式时间内转化为A，则称A为NP-hard问题。 NPC问题一定是NP-hard问题。 一些典型的NP完全问题通过问题变换的技巧，可以将2个不同问题的计算复杂性联系在一起。这样就可以将一个问题的计算复杂性归约为另一个问题的计算复杂性，从而实现问题的计算复杂性归约。 证明一个问题是NP完全问题分为两个步骤： 证明该问题是NP问题。 证明NP问题中的每一个问题都能在多项式时间内归约为该问题。 由于多项式问题具有传递性，因此只需证明一个已知的NP完全问题能够在多项式时间内归约到该问题即可。 下图给出了进行NP完全证明的结构，树的根为CIRCUIT-SAT。 电路可满足性问题（CIRCUIT-SAT）由《算法导论》第二版引理34.5：电路可满足性问题属于NP类，以及引理34.6：电路可满足性问题是NP难度的，结合NP完全性的定义可直接推出结论： 电路可满足性问题是NP完全的。 合取范式的可满足性问题（SAT）证明： SAT ∈ NP: 给定该问题的一个实例，用证书y={1, 1, 1}作为输入，对于给定的布尔公式x，我们都能按照布尔公式的数学运算规则在多项式时间内求解出来。 在多项式时间内将Circuit-SAT归约到SAT： 将电路中的输入用布尔变元表示，将电路中的每一个逻辑门用布尔公式来对应，就可以将Circuit-SAT问题归约到SAT问题。 显然，这是在多项式时间内完成的，因此SAT是NP完全问题。 三元合取范式的可满足性问题（3-CNF-SAT） 在这个问题的证明之前先补充一下合取范式（CNF）的定义。 如果一个布尔公式可表示为所有字句的“与”，且每个字句都是一个或多个文字的“或”，则称该布尔公式为合取范式（CNF）。 如果公式中的每个字句恰好都有三个不同的文字，则称该布尔公式为3-CNF。 例如，布尔公式$$(x_1 \vee -x_1 \vee -x_2)\wedge(x_3 \vee x_2 \vee x_4)\wedge(-x_1 \vee -x3 \vee -x_4)$$就是一个3-CNF，其三个字句中的第一个为$(x_1 \vee -x_1 \vee -x_2)$，它包含3个文字$x_1$，$- x_1$，$-x_2$。 证明： 3-CNF-SAT ∈ NP： 这里的证明与上面的SAT问题是类似的。同样给定一个证书y作为输入，对于一个给定的合取范式，都可以在多项式时间内验证合取范式的值是1还是0。 在多项式时间内将SAT归约为3-CNF-SAT： 由于这里的证明对离散数学的要求较高，且老师上课时也没有细讲这部分内容，故只给出步骤，详细的证明可参考《算法导论》第二版定理34.10。 Ⅰ. 为输入公式画出一棵二叉“语法分析”树，文字作为树叶，连接词作为内部顶点。 Ⅱ. 把每个字句变换为合取范式。 Ⅲ. 继续对公式进行变换，使每个字句恰好有三个不同的文字。 从上面的步骤可以看出，SAT可以在多项式时间内归约到3-CNF-SAT，因此3-CNF-SAT是NP完全问题。 团问题（CLIQUE）证明： CLIQUE∈NP： 对于给定的图G(V, E)，如果给定顶点集V’作为证书，我们可以验证对于任意一对顶点u, v∈V’, 通过检查边(u, v)是否属于E，从而验证V’是否是一个团。显然，这是在多项式时间内完成的。 在多项式时间内将3-CNF-SAT归约到CLIQUE： 给定一个含有k个字句的3-CNF，假定其是可满足的，即3-CNF的结果为1。我们总是可以构造一个3k个顶点的图，构造方法是在不同的三元组、且不是自己的非的节点之间连线。 一共有k个分组，每个分组中的节点之间不能互相连接，而且这个3-CNF是可满足的。那么每个分组都会有一个节点与其他分组的节点相连，将每个分组的选出的那个节点互相连接起来，就是最大团。显然，最大团有k个节点。 下面给出《算法导论》中的一个k=3的实例，图中浅色的节点为每个分组中选出的节点。即3-CNF-SAT的一个可满足赋值为$x_2=0, x_3=1, x_1=0 或 1$。 归约过程在多项式内可以完成，因此团问题是NP完全问题。 顶点覆盖问题（VERTEX-COVER）证明： VERTEXT-COVER∈NP： 对于给定的图G(V, E)，如果给定顶点集V’作为证书，对于每条边(u, v)∈E，我们可以检查是否有u∈V’或v∈V’。这一验证在多项式时间内即可完成。 在多项式时间内将CLIQUE归约到VERTEX-COVER： 设G=(V, E)是CLIQUE的一个实例，设G的最大团为V’，取图G的补图，设补图上的边为E’，补图上的点为V-V’，那么V-V’是一个顶点覆盖。 原理：从E’中取任意的一条边(u, v)，那么在G中，边(u, v)是不存在的，那么u或v至少有一个在V-V’中。由于边(u, v)是任意取自E’的，即在补图中，任意一条边上都至少有一个点是属于V-V’的，即满足顶点覆盖的定义。 下面给出一个例子，V’ = {u, v, x, y}，V-V’ = {z, w}。 同样，这个归约过程能够在多项式时间内完成，因此顶点覆盖问题是NP完全问题。 哈密顿回路问题（HAM-CYCLE）证明： DIR-HAM-CYCLE∈NP： 对于一个给定的图G(V, E)，我们可以简单验证一个顶点序列是否经过所有顶点一次且仅一次，而且最后能够回到源点。这个过程显然是在多项式时间内完成的。 在多项式时间内将3-CNF-SAT归约到DIR-HAM-CYCLE： 构造一个能够表达3-CNF中的文字和子句的图结构，每行中的节点代表3-CNF中的每个文字，如第一行中的节点都代表了x1，那么跨行之间的节点之间即可代表3-CNF中的字句。 如果不清楚文字和字句的概念，可以参考上面3-CNF中关于合取范式的定义。 首先进行一个定义：当$x_i=1$时，遍历的顺序是从左到右，当$x_i=0$时，遍历的顺序是从右到左。从最上面的源点出发，以某种方式连接这些点以满足3-CNF，只要满足图中的3-CNF，那么这个图就是有向哈密顿回路。这个过程是在多项式时间内完成的。 接下来还要进行另外一个归约，才可以达到我们的目标： HAM-CYCLE∈NP： 与DIR-HAM-CYCLE的验证方法相同，这里不再赘述。 在多项式时间内将DIR-HAM-CYCLE归约到HAM-CYCLE： 给定一个具有n个顶点的有向图G=(V, E)，可以在多项式时间内构建一个具有3n个顶点的无向图G’ 以上两个归约都是在多项式时间内完成的，故哈密顿回路是NP完全的。 旅行商问题（TSP）证明： TSP∈ NP： 给定该问题的一个实例，用n个顶点组成的回路作为证书，我们可以验证该回路是否只包含每个顶点一次，并且检查各边费用之和是否小于k。这个过程能够在多项式时间内完成。 在多项式时间内将哈密顿回路归约到TSP： 设G=(V, E)是HAM-CYCLE的一个实例，可以构造对应的一个TSP实例。建立一个完全图G‘=(V, E’)，定义费用函数c为： 然后求解完全图G’上最大限定花费为0的路线即可。 下面来说明当且仅当图G’中有一个费用至多为0的回路的时候，G中才具有一个哈密顿回路： 假定图G中有一个哈密顿回路h。h中的每条边都属于E，因此在G’中的费用为0。因此，h在G‘中是费用为0的回路。 反之，假定图G’中有一个费用h‘至多为0的回路，回路上每条边的费用必为0。因此，h’仅包含E中的边。 这样，我们就得出结论，h’是图G中的一个哈密顿回路。 上述归约过程在多项式时间内完成，故旅行商问题是NP完全的。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER6 动态规划]]></title>
    <url>%2F2018%2F12%2F06%2FCHAPTER6%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[概念分治法将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解而得到原问题的解。 动态规划适用于子问题不是独立的情况，也就是个子问题包含公共的子子问题。动态规划对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。 动态规划的算法可分为以下4个步骤： 描述最优解的结构。 递归定义最优解的值。 按自底向上的方式计算最优解的值。 由计算的结果构造一个最优解。 0-1背包问题假设有n个物品，它们的重量分别为$w_1, w_2, …, w_n$，价值分别为$v_1, v_2, …, v_n$，给一承重为W的背包，求装入的物品具有最大的价值总和。 首先给出利用动态规划计算0-1背包问题的递归式： 在这个递归式中，$OPT(i, W)$表示前i件物品放入容量为W的背包中的最大价值。 初始化时，$OPT(0, j) = 0$，意为当没有物品放入时，不管背包容量多少，其最大价值为0；$OPT(i, 0)$意为当背包容量为0时，不管从前i件物品中怎么取，最大价值都是0。 接着进行动态规划，在已知$f(i-1, j)​$时，即已知在前$i-1​$件物品放入容量为j的背包时的最大价值情况下，求$f(i, j)​$。 在求$f(i, j)$时，首先判断物品i的重量是否超过目前背包的重量j，如果超过，则这个物品i放不进背包，则$f(i, j) = f(i-1, j)$。如果背包可以放下物品i，则尝试把背包中的重量减去物品i的重量$w_i$，这样$f(i-1, j-w_i)$表示前i-1件物品在背包容量为$i-w_i$下的最大价值，此时如果放入物品i，那么价值就变为$f(i-1, j-w_i)+v_i$。判断$f(i-1, j-w_i)+v_i$与$f(i-1, j)$的大小，选择较大的一个作为在背包容量为i下的最大价值。以上就是对于这个递归式的算法描述。 相对应的伪代码如下图所示： 可以将这个二维数组可视化，有如下图所示的五个物品和其对应的价值，且背包容量为11，那么如何让背包中装入的物品有最大的价值？ 遍历过程如下所示，从上到下代表i的遍历，从左到右代表j的遍历，最后可得到最大价值为40。 0-1背包问题已经被证明是NP完全问题，而它却有着一个动态规划解法，该解法有着O(nW)的时间复杂度，其中n是物品的个数，W是背包限制的最大负重。但是这种动态规划的算法称为伪多项式时间算法，这种算法不能真正意义上实现多项式时间内解决问题。 最长公共子序列（LCS问题）以最长公共子序列为例，将动态规划的四个步骤按部就班地走一遍。 Step1 描述最优解的结构（分析问题）假设$X = A, B, C, B$，$Y = B, D, C, A, B$，我们可以容易地想到暴力解法，即将枚举出X中的所有子序列，然后检查每个子序列是否是Y的子序列。假设X和Y的长度分别是m和n，那么暴力解法的时间复杂度是$O(2^mn)$。 我们可以观察到，LCS问题具有最优子结构，设$X=&lt;x_1,x_2,…,x_m&gt;和Y=&lt;y_1,y_2, …,y_n&gt;$为两个序列，$Z = &lt;z_1, z_2, … ,Z_k&gt;$为X和Y的任意一个LCS，则有LCS的最优子结构定理： 如果$x_m=y_n$，那么$z_k = x_m = y_n$，而且$Z_{k-1}$是 $X_{m-1}$和$Y_{n-1}$的一个LCS。 如果$x_m \neq y_n$，那么$z_k \neq x_m$意味着$Z$是 $X_{m-1}$和$Y$的一个LCS。 如果$x_m \neq y_n$，那么$z_k \neq y_n$意味着$Z$是 $X$和$Y_{n-1}$的一个LCS。 Step2 递归定义最优解的值（递归解决）用$C[i,j]$表示$X_i$和$Y_j$的最长公共子序列LCS的长度，则有公式： Step3 按自底向上的方式计算最优解的值（计算LCS的长度）LCS_LENGTH以两个序列为输入，将LCS的长度保存到二维数组c中，将构造过程保存到另一个二维数组b中，伪代码如下所示： 1234567891011121314151617181920212223def LCS_LENGTH(X,Y): m = length(X) n = length(Y) # 初始化 for i = 1 to m: c[i][0] = 0 for j = 1 to n: c[0][j] = 0 # 计算LCS的长度 for i = 1 to m: for j = 1 to n: if x[i] == y[j]: c[i, j] = c[i-1, j-1] + 1 b[i, j] = '\' elif c[i-1, j] &gt;= c[i, j-1]: c[i, j] = c[i-1, j] b[i, j] = '|' else: c[i, j] = c[i, j-1] b[i, j] = '-'return c, b Step4 由计算的结果构造一个最优解（构建LCS）根据LCS_LENGTH返回的表b，可以构建一个LCS序列，输出所有值为’\’的元素，即可得到LCS，PRINT_LCS的伪代码如下所示： 123456789def PRINT_LCS(b, X, i, j): if i==0 or j==0: return 0 if b[i, j] == '\': PRINT_LCS(b, X, i-1, j-1) print X[i] elif b[i, j] == '|': PRINT_LCS(b, X, i-1, j) elif PRINT_LCS(b, X, i, j-1) 为了加深理解，使用C++实现了以上伪代码，使用PPT上的例子，最终得出结果如下图所示： 全部C++代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include "stdafx.h"#include &lt;iostream&gt;using namespace std;#define m 4#define n 5#define skew 0#define up 1#define level 2void lcs_length(char*X, char*Y, int c[m+1][n+1], int b[m+1][n+1])&#123; int i, j; for (i=0; i&lt;m; i++) c[i][0] = 0; for (j=0; j&lt;n; j++) c[0][j] = 0; for (i=1; i&lt;=m; i++) for (j=1; j&lt;=n; j++) &#123; if (X[i] == Y[j]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = skew; &#125; else if (c[i-1][j] &gt;= c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = up; &#125; else &#123; c[i][j] = c[i][j-1]; b[i][j] = level; &#125; &#125;&#125;void print_lcs(int b[m+1][n+1], char* X, int i, int j)&#123; if (i==0 || j==0) return; if (b[i][j] == skew) &#123; print_lcs(b, X, i-1, j-1); cout &lt;&lt; X[i] &lt;&lt; ' '; &#125; else if(b[i][j] == level) print_lcs(b, X, i, j-1); else print_lcs(b, X, i-1, j);&#125;int main()&#123; char X[m+1] = &#123;' ','A','B','C','B'&#125;; char Y[n+1] = &#123;' ','B','D','C','A','B'&#125;; int c[5][6] = &#123;0&#125;; int b[5][6] = &#123;0&#125;; int i, j; cout &lt;&lt; "The X is ABCB" &lt;&lt; endl; cout &lt;&lt; "The Y is BDCAB" &lt;&lt; endl &lt;&lt; endl; lcs_length(X, Y, c, b); for(i=0; i&lt;=m; i++) &#123; for (j=0; j&lt;=n; j++) cout &lt;&lt; c[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl &lt;&lt; "The length of LCS is: " &lt;&lt; c[m][n] &lt;&lt; endl; cout &lt;&lt; "The LCS is: "; print_lcs(b, X, m, n); return 0;&#125; 编辑距离（Edit Distance）假设X和Y是两个字符串，我们要用最少的操作将X转换为Y，三种操作可供使用，分别是删除、插入和替换，最少操作的数目称为编辑距离。 与LCS类似，也可得到编辑距离的公式： 下面给出一个例子，具体的实现与LCS类似，这里不再赘述。 矩阵连乘问题（Chain MatrixMultiplication）给定n个矩阵$｛A1,A2,…,An｝$，其中$Ai$与$Ai+1$是可乘的，$i=1,2 ,…,n-1$。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。 假如我们要得到计算从$A_i$到$A_j$的最优计算次序。首先假设这个计算次序在矩阵$A_k$和$A_{k+1}$之间断开，且$i \leq k &lt; j$，则计算量为前一部分的计算量、后一部分的计算量以及两部分相乘的计算量之和。 可以递归地定义$C[i, j]​$为： 可以看到，$k$的位置只有$j-i$种可能，此算法的时间复杂度为$O(n^3)​$，给出一个这种动态规划算法的计算实例。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER5 分治法]]></title>
    <url>%2F2018%2F12%2F05%2FCHAPTER5%20%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法是将一个复杂的问题分成一些规模较小而结构与原问题相似的子问题，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 分治法在每一层的递归上都有三个步骤： 分解（Divided）：将原问题分解成一系列子问题。 解决（Conquer）：递归地解各子问题。 合并（Combine）：将子问题的结果合并成原问题的解。 假设我们将原问题分解成a个子问题，每一个的大小是原问题的1/b。如果分解和合并的时间各为D(n)和C(n)，则可得到递归式： 合并排序（Merge Sort）当合并排序的运行时间如下分解： 分解：仅计算出子数组的中间位置，需要常量时间，故$D(n) = \Theta(1)$。 解决：递归地解两个规模为n/2的子问题，时间为$2T(n/2)$。 合并：在一个含有n个元素的子数组上，MERGE过程的运行时间为$\Theta(n)$，则$C(n) = \Theta(n)$。 因此，合并排序的最坏运行时间$T(n)$的递归表示是： 由之前第一章介绍的主定理，我们可以得到$T(n) = \Theta(nlgn)$，这里的$lgn$代表$log_2n$。同样，我们也可以通过递归树得到相同的答案。 最大子数组问题（Maximum Subarray Problem）对于一个具有连续连续值的数组A，寻找A的和最大的非空连续子数组，我们称这样的连续子数组为最大子数组。例如，对于下图的数组，A[1…16]的最大子数组是A[8…11]，其和为43。在实际的例子中可表示在第8天买入股票，并在第11天卖出，获得的收益为43美元。 使用分治法可以求解最大子数组问题。首先找到数组的中间点，将数组分为左右两个数组，那么最大子数组可能存在于下列三种情况之一： 完全位于左边的数组中。 完全位于右边的数组中。 跨越了左右两个数组。 对于前两种情况，使用同样的方式递归地划分为规模最小的子数组求解即可。对于第三种情况，我们采用的算法是从中间点向两边遍历，分别求出两边的最大子数组，然后将左右两边的子数组相加即为跨越中点的最大子数组。 下面给出算法的伪代码： 对FIND-MAXIMUM-SUBARRAY算法的运行时间进行分析： 首先计算出子数组的中间位置，需要常量时间$\Theta(1)$，然后递归地解两个规模为n/2的子问题，时间为$2T(n/2)$，调用FIND-MAX-CROSSING-SUBARRAY花费了$\Theta(n)$时间，则$T(n) = \Theta(1) + 2T(n/2) + \Theta(n) $，用主方法或递归树求解此递归式可得$T(n) = \Theta(nlgn)$。 斐波那契数列（Fibonacci Number）对于斐波那契数，我们有$F_0=0, F_1=1, F_n=F_{n-1}+F_{n-2}$。利用分治策略，我们可以将斐波那契数列转换为矩阵乘幂的问题，如下图所示： 使用分治法，我们将矩阵递归地分解成两个相同的矩阵，再将这两个矩阵相乘即可。 故$T(n) = T(n/2)+O(1) = T(n)/4+2O(1) = … = T(n/2^{logn})+O(logn)×O(1)$。 整数乘法（Integer Multiplication）假设x, y分别为两个n-bit的整数，如果要将它们相乘，模拟使用手动乘法得到的时间复杂度是$\Theta(n^2)$，考虑分治法。 令$x = (10^ma+b), y=(10^mc+d)$，如$x=1234567890, m=5, a=12345, b=67890$。那么$x×y = (10^ma+b)(10^mc+d)= 10^{2m}ac+10^m(bc+ad)+bd$，这里的时间复杂度$T(n) = 4T(n/2)+O(n)$，使用主方法可得$T(n) = O(n^2)$。 Anatolii, Karatsuba在1962年提出了一个只需要三次子乘法就可以完成运算的算法，其时间复杂度的递归表示为$T(n) = 3T(n/2)+O(n)$，使用主方法可得$T(n) = O(n^{lg3})$。 矩阵乘法（Matrix multiplication）给定一个n维矩阵X和Y，计算Z=XY。我们可以使用分治法求解这个问题。 分解：将X和Y分解为n/2维的矩阵。 解决：使用8次矩阵乘法递归地将这些n/2维的矩阵相乘。 合并：使用4次矩阵加法将矩阵合并。 下面给出一个例子： 1969年Strassen提出了一个只需要7次矩阵乘法就可以完成运算的算法，算法将原矩阵分为7个新的子矩阵如下图所示： 然后进行计算： 此算法的时间复杂度为$T(n) = 7T(n/2)+\Theta(n^2)=O(n{log_27})=O(n^{2.81})$。 凸包问题（The Convex Hull Problem）假设平面上有一系列点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来，当这个多边形是凸多边形的时候，我们就叫它凸包，凸包问题就是求构成凸包的点，如下图所示。 使用蛮力法是最容易想到的，思路是由两点确定一条直线，如果剩余的点都在这条直线的同一侧，那么认为这两个点是构成凸包的点。蛮力法的时间复杂度为$O(n^3)$。 下面我们介绍解决凸包问题的分治法，下面为具体步骤和图例： 将所有点放在二维坐标系里，那么横坐标最大的两个点$p_1、p_n$一定是凸包上的点（具体可以用反证法证明，这里不展开说）。直线$p_1p_n$将点集合分为了两部分，分别叫上包和下包。 对于上包，求距离直线$p_1p_n$最远的点，即下图中的$p_{max}$。 作直线$p_1p_{max}$和$p_np_{max}$，把$p_1p_{max}$左侧的点当作上包，把$p_np_{max}$右侧的点也当作是上包。 重复步骤2、3。 对下包也做类似的操作。 分治法的时间复杂度为$T(n) = 2T(n/2) + O(n) = O(nlogn)$。 三格骨牌问题（Tromino Tiling）对于三格骨牌问题，同样可以用分治法求解，解决这个问题的思想是每次都将平板分成四块同等大小的子平板。 例如，在插入三格骨牌时，将平板分成四块，由于洞位于左上方的子平板，因此将三个骨牌放置为如图所示的位置，以确保四块子平板的大小相等。递归地进行这个过程即可得出结果。 最邻近点问题（Finding the Closest Pair of Points）顾名思义，最邻近点问题即在平面点集中找出距离最近的两个点。使用时间复杂度为$O(n^2)$的蛮力法可以解决这个问题。 下面我们介绍解决这个问题的分治法，首先将点集划分为两个部分，然后递归地寻找最近的点，若找到最近的两个点之间的距离为$\delta$，则寻找是否存在分别属于两个部分的点之间的距离小于$\delta$，算法的时间复杂度为$T(n) = O(n)+2T(n/2)+O(n)=O(nlgn)$。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER4 贪心算法]]></title>
    <url>%2F2018%2F12%2F03%2FCHAPTER4%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法即不从整体最优考虑，只是做出在当前看来最好的选择，它所做出的选择只是在某种意义上的局部最优选择。贪心算法对于大多数优化问题都能得到整体最优解（如单源最短路径问题、最小生成树问题等），虽然说并不总是这样的。在一些情况下，即使贪心算法不能得到整体最优解，但是其最终的结果是最优解的近似。 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，每作一次贪心选择就将所求问题简化为规模更小的子问题。 下面来看一些具体的例子。 区间调度（Interval Scheduling）问题描述：假如我们有多个任务，每个任务都具有各自的开始时间和结束时间，求在任务不重叠的情况下任务的最大组合数。 根据贪心算法，我们可以从不同的角度分析这个问题。 Rule1：选择开始最早的任务 每次选择当前最先开始的任务，并依次选到最后一个。 从这个例子看出，失败！ Rule2：选择区间最短的任务 从最短的任务开始选择，并依次选择不重复的当前最短的任务，按照所用时间长短排序。 从这个例子看出，失败！ Rule3：选择冲突最少的任务对于每一个任务，计算与它冲突的任务个数，每次选择当前与其冲突最少的任务。 从这个例子看出，还是失败了。 Rule4：选择结束最早的任务每次选择当前最早结束的任务，并依次选到最后一个。 可以看出，在上面的三个例子中，本算法都是可行的。事实上，Rule4的算法是解决区间调度问题的一个可行算法。直观上来说，按这种方法选取的任务为未安排的任务留下了尽可能多的时间。也就是说，该算法的贪心选择使剩余的可安排时间段极大化，以安排尽可能多的不重叠活动。这个算法的时间复杂度是$O(nlogn)$。 集合覆盖（Set Cover）问题描述：在一个集合$B$以及$B$内元素构成的若干集合$S_1, S_2, … , S_m$中，找到数目最少的$S_i$使得$S_i$中的所有元素都包含了$B$中所有元素。为便于理解，给一个具体的例子。例如，$B$={1,2,3,4,5}，$S_1$={1,2,3}，$S_2$={2,4}，$S_3$={3,4}，$S_4$={4,5}，可以找到一个集合覆盖$S_1, S_4$。 其实集合覆盖问题是一个NP难的问题，但是我们仍然可以用贪心算法得到这个问题的近似解。 假设我们要在城镇里建几所学校，需要满足两点：1、每个学校都要建在一个城镇里。2、城镇离学校的距离不能超过30英里。 根据贪心算法，我们可以得到非常接近的解： 选出这样一个学校，即它覆盖了数量最多的城镇。 重复第一步，直到覆盖所有的城镇。 这是一种近似算法，贪心算法的运行时间为$O(n^2)​$，可得到如下图所示的结果，图中点的位置代表城镇的位置。 最小生成树（Minimum Spanning Tree）用贪心算法设计策略可以设计出构造最小生成树的有效算法，如Prim算法和Kruskal算法，尽管它们做贪心选择的方式不同。 关于MST的这两个算法相信大家应该都十分熟悉了，这里便不再展开。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER3 最大匹配问题]]></title>
    <url>%2F2018%2F12%2F02%2FCHAPTER3%20%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于匹配的几个定义匹配（Matching）一个匹配是一个边的子集合$M\subseteq E$，且满足对所有顶点$v\in V$，$M$中至多有一条边与$v$相关联。也可以简单地说，一个匹配就是一个边的集合，其中任意两条边之间都没有公共顶点。 下面给出一个例子： 最大匹配（Maximum Matching）简单地说，最大匹配是一个图的所有匹配中边数最多的那个匹配。给出一个例子： 二分图（Bipartite Graph）二分图是图论中的一种特殊模型，设$G=(V,E)$是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集，则称图$G$为一个二分图。 完全匹配（Perfect Matching）简单地说，当一个图的某个匹配中所有的顶点都是匹配点，那么这个匹配就是完美匹配。同样给出一个例子： 在二分图中寻找最大匹配从本质上来说，二分图匹配其实是最大流的一种特殊情况。是解决这个问题的关键技巧在于建立一个流网络，其中流对应于匹配，如下图所示。 可以看出，图中添加了源点s和汇点t，它们是不属于V的新顶点。令已有边的容量为无穷大，且令s和t分别连接二分图，并设置其容量为1。这时，我们通过Ford-Fulkerson方法计算得到的最大流就等于最大二分匹配。 在一般图中寻找最大匹配在一般图中，我们使用增广路径（Agumenting path）来寻找最大匹配。如果一条路径的首尾是非匹配点，路径中除此之外（如果有）其他的点均是匹配点，那么这条路径就是一条增广路径。 如下图所示，我们从非匹配点9出发，经过匹配点4、8、1、6，最后在非匹配点2停止。所以，9-&gt;4-&gt;8-&gt;1-&gt;6-&gt;2 就是一条增广路径。 由于增广路径的首尾是非匹配点，那么增广路径的首尾边必为非匹配边。由于增广路径中匹配边与非匹配边一次交替，所以非匹配边的数目比匹配边多一条。我们可以利用这个特性来改进匹配，只要将匹配边与非匹配边互换即可，如下图所示。 所以，只要不断地迭代这个过程，直至找不到增广路径为止，就可以找到一般图的最大匹配。 补充：若要寻找带权一般图上的最大匹配，则在上面算法的基础上加个权重和判断即可。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER2 最大流与最小割]]></title>
    <url>%2F2018%2F12%2F01%2FCHAPTER2%20%E6%9C%80%E5%A4%A7%E6%B5%81%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[流网络$G=(V, E)​$是一个简单有向图，在V中指定顶点s和t，分别称为源点和汇点，有向图G中的每一条边$(u, v) \in E​$，对应有一个值$cap(u, v) \geq0​$，称为边的容量，这样的有向图G称作一个流网络，下图是一个例子。 $f(v, u)​$称作是从顶点u到顶点v的流，它满足以下性质： 容量限制：对所有$u, v \in V$，要求$f(u, v) \leq c(u, v)$。 反对称性：对所有$u, v \in V$，要求$f(u, v) = -f(v, u)$。 如果有一组流满足以下条件，那么这组流就成为一个可行流： 源点s：流出量 = 整个网络的流量 汇点t：流入量 = 整个网络的流量 中间点：总流入量 = 总流出量 最大流即网络G所有的可行流中，流量最大的一个可行流。 Ford-Fulkerson方法之所以称为Ford-Fulkerson方法而不是算法，是由于它包含具有不同运行时间的几种实现。Ford-Fulkerson方法依赖于三种重要思想：残留网络、增广路径、割。这三种思想是最大流最小割定理的精髓，该定理用流网络的割来描述最大流的值，我们将会在后面谈到。以下给出Ford-Fulkerson方法的伪代码： 12345Ford-Fulkerson-Method(G, s, t): initialize flow f to 0 while there exists an augmenting path p: do augment flow f along p return f 最大流最小割定理首先来介绍割的概念，一个割会把图G的顶点分成两个不相交的集合，其中s在一个集合中，t在另外一个集合中。割的容量就是从A指向B的所有边的容量和，最小割问题就是要找到割的容量最小的情况。下面给出两个例子，割的容量分别为30和62。 接着介绍残留网络和增广路径的概念，给定一个流网络$G$和一个可行流，流的残留网络$G_f$拥有与原网相同的顶点。流网络$G$中每条边将对应残留网中一条或者两条边，对于原流网络中的任意边(u, v)，流量为f(u, v)，容量为c(u, v)： 如果f(u, v) &gt; 0，则在残留网中包含一条容量为f(u, v)的边(v, u); 如果f(u, v) &lt; c(u, v)，则在残留网中包含一条容量为c(u, v) - f(u, v)的边(u, v)。 下图为一个例子： 对于一个已知的流网络$G=(V, E)$和流$f$，增广路径$p$为残留网络$G_f$中从s到t的一条简单路径。 最大流最小割定理：网络的最大流等于某一最小割的容量，并且下列条件是等价的： $f$是$G$的一个最大流。 残留网络$G_f$不包含增广路径。 对$G$的某个割$(S, T)$，有$|f| = c(S, T)$。 基本的Ford-Fulkerson算法根据，我们可以求给定有向图的最大流。下面给出《算法导论》中的一个实例： 上图中的左边表示开始时的残留网络，右边表示将增广路径加入残留网络后得到的新的可行流，通过三次迭代即可得到最大流，根据最大流最小割定理，我们同样可以得到最小割。 再通过本课程课件上的一个例题进行练习。 同样通过基本的Ford-Fulkerson算法，可得到答案如下。 Edmonds-Karp算法Edmonds和Karp曾经证明了如果每步的增广路径都是最短，那么整个算法会执行$O(mn)$步，Edmonds-Karp算法是用广度优先搜索来实现对增广路径p的计算的，实现的伪代码如下图所示。 由于在广度优先搜索时最坏情况下需要$O(m)$次操作，所以此算法的复杂度为$O(m^2n)$。之后，Dinitz改进了Edmonds-Karp算法，得到一个时间复杂度为$O(mn^2)​$的算法，下面给出一张关于最短增广路径算法研究历史的表格，这里就不再展开了。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CHAPTER1 函数的增长与递归式]]></title>
    <url>%2F2018%2F11%2F27%2FCHAPTER1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF%E4%B8%8E%E9%80%92%E5%BD%92%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[渐进记号用来表示算法的渐进运行时间的记号是用定义域为自然数集$N={ 0, 1, 2, …}$的函数来定义的，这些记号便于用来表示最坏情况运行时间$T(n)$，因为$T(n)​$一般仅定义于整数的输入规模上。 $\Theta$记号（紧渐进界）对于$\Theta​$记号有如下的定义： $\Theta$记号限制一个函数在常数因子内，如图所示，$n_0$是最小的可能值。如果存在正常数$n_0, c_1, c_2$使得在$n_0$右边$f(n)$的值永远在$c_1g(n)$与$c_2g(n)$之间，那么可以写成$f(n) = \Theta(g(n))​$。 O记号（渐进上界）对于$O$记号有如下的定义： $O$记号给出一个函数在常数因子内的上限。如图所示，$n_0$是最小的可能值。如果存在正常数$n_0, c$使得在$n_0$右边$f(n)$的值永远等于或小于$cg(n)$，那么可以写成$f(n) = O(g(n))$。 Ω记号（渐进下界）对于$Ω​$记号有如下的定义： $Ω$记号给出一个函数在常数因子内的下限。如图所示，$n_0$是最小的可能值。如果存在正常数$n_0, c$使得在$n_0$右边$f(n)$的值永远等于或大于$cg(n)$，那么可以写成$f(n) = Ω(g(n))$。 o记号（渐进非紧上界）$O$记号所提供的渐进上界可能是紧的，但也有可能不是。例如，$2n^2=O(n^2)$是一个紧的上界，但$2n=O(n^2)$却不是一个紧的上界。于是，我们使用$o$记号来表示一个紧的上界。 对于$o​$记号有如下的定义： 例如，$2n=o(n^2)$，但$2n^2 \neq o(n^2)$。 $O$记号与$o$记号的定义是类似的，主要区别在于对于$f(n)=O(g(n))$，界$0 \leq f(n) \leq cg(n)$对某个常数$c&gt;0$成立即可，而对于$f(n)=o(g(n))$，界$0 \leq f(n) \leq cg(n)$对所有常数$c&gt;0$成立。 $ω$记号（渐进非紧下界）$ω$记号与$Ω$记号的关系就与前面小o和大o之间的关系是类似的，我们用$ω$记号表示一个紧的下界。 对于$ω$记号有如下的定义： 例如，$n^2/2=ω(n)$，但$n^2/2\neqω(n^2)$。 函数间的比较实数的许多关系属性可以用于渐进比较，以上的记号之间具有传递性和对称性，下面假设$f(n)$和$g(n)$是渐进正值函数。 解递归式的三种方法求解递归式，即找出解的渐进“$\Theta$”或“$O$”界的方法主要有三种： 代换法：先猜某个界存在，然后用数学归纳法证明该猜测的正确性。 递归树方法：将递归式转换成树形结构，树中的节点代表在不同递归层次付出的代价。 主方法：给出递归形式$T(n) = aT(n/b)+f(n)$的界，其中$a \geq 1, b&gt;1$，$f(n)$是给定的函数。这种方法要记忆三种情况，就可以确定很多简单递归式的界了。 代换法用代换法解递归式需要两个步骤： 猜测解的形式。 用数学归纳法找出使解真正有效地常数。 递归树方法虽然代换法给递归式的解的正确性提供了一种简单的证明方法，但是有的时候很难得到一个好的猜测。此时，画出一个递归树是一种得到好猜测的直接方法。 设$T(n) = 3T(n/4)+n^2​$，则使用递归树求解该递归式的过程如下图所示： 主方法设$a \geq 1, b&gt;1$，$f(n) $为一函数，$T(n)$由递归式$$T(n) = aT(n/b)+f(n)$$对非负整数定义，那么$T(n)$有如下的渐进界： 求解和式时有一个比较常用的公式，假设$f(k)$是单调递增的函数，那么有如下的性质：]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
